---
layout: post
title: Front-End Automation Testing
tags: [testing,selenium,docker, front-end]
---

Front-end automation testing. If you want to see a developer shake his/her head, snarl, and take two steps back, just say those four words. At least that is what I do. I've written plenty of javascript unit tests over the years, but have never really worked with mimicking clicks on a headless browser. I've written unit tests for React components that mock a user clicking on a button, but that doesn't really compare to an actual user clicking on a button and having the browser perform all of the events that go along with it. Automating front-end testing is a completely different beast.

I've spent the past month at work researching and then implementing automated front-end tests for a React client that I previously worked on. The first thing I did, after snarling of course, was to hit the internet and find the best frameworks/tools that I could use to facilitate the testing. The way that I usually tackle a project like this is to read blogs/articles and talk to other developers to get a feel for a few frameworks, and then dive head first in and try to write a few tests with each toolset against my application. While looking, I had a few things I was looking for that would make a tool a winner for me: 
  
  1. It is easy to setup. 
  2. It is easy to work with and ideally works well with React.
  3. It handles as much interaction and setup of Selenium as possible so I have to deal with it as little as possible. 

The first solution I tested was [Test Cafe](https://devexpress.github.io/testcafe/). The test structure is a little different than other frameworks, but I think it is still very readable, plus it has an [extension](https://github.com/DevExpress/testcafe-react-selectors) that allows you to use React selectors instead of using an obscene amount of Xpath. I was able to write a few tests and get it up and running against selenium in no time ([this](https://hackernoon.com/e2e-testing-react-applications-with-testcafe-8edb605ec66c) article helped out a lot.) In the end, I moved away from Test Cafe only because it is still fairly new and I was worried that the rest of the team wasn't going to like the different test structure. Everyone else seems to lean more towards the describe/it structure of [Mocha](https://mochajs.org/) similar to how we write our unit tests.

The next solution I tried out was [Nightwatch](http://nightwatchjs.org/). At first I was a little hesitant, but once I started writing tests with [page objects](https://martinfowler.com/bliki/PageObject.html), I was hooked. Their API is very well documented, and although they don't support using React selectors, by using page objects, I was able to contain each section of the app's Xpath to a single file which made it really easy to use common actions while testing the entire site. (An example of this is logging in. Most tests will require that this happens before  anything else can be done, so the code to perform the required actions needs to be in a common place that all tests can access.) Another cool feature that Nightwatch's API has is waitForElementVisible(). This allows you to give it an element and a max amount of time, and it will either wait that amount of time and fail, or continue on its merry way when the element is visible. This is a must-have because what you will constantly run into while testing is that you will need to add sleep statements all over the place because the browser doesn't render the DOM instantly. The problem with adding sleep statements though is that you don't really know how long to wait. At least in my application, most actions trigger a call to a different server to retrieve data. Usually this call is fairly fast, but every so often it takes a little longer. If using a sleep statement, you have to have it sleep for the max time you are willing to wait otherwise you will get random failures when elements that you need to verify are not on the page. Nightwatch absorbs this pain.

After a few days of writing Nightwatch front-end tests, I had built up a pretty nice suite of tests that were extendable, readable, and worked. What more can you ask for? After mentioning this to my manager, he informed me that he didn't want us to use Nightwatch and that we had to use two predetermined php frameworks, behat+mink (I'm not even going to link to them because I wouldn't recommend using them, just save the time of even reading about either of them and learn something else), even though we had already discussed using javascript frameworks to handle the testing. In the end I learned to get email confirmation, that I can refer back to as proof later on, before spending a week moving in the wrong direction. At least I was able to spend some time testing and learning a few cool solutions before being forced to use the [try to forget name] framework.

No matter which framework you use, eventually you will probably want it to run regularly as part of you CI. In theory, this seems easy since you have been running it on your computer while writing the tests, how different can it be. It turns out that it is very different. The main difference is that locally a browser will open and the tests will run against it. On your CI server though, you can't do this. You need to run the browser in headless mode (aka Ichabod Crane style). I struggled with this for a day or so. Depending on your OS, you'll need to always have Xvfb running in the background. Then you will need to install the exact version of Chrome/Firefox you want to test against, next install Chrome/Firefox drivers that are needed, and finally have a process that starts Selenium. In the end you will have a jenga tower of software components that if you are lucky, can be used to run your automated test suite. I was not so lucky and ran into one problem after another. In the end, I abandoned the entire shaky jenga tower and used [this awesome and very easy to use docker image](https://github.com/SeleniumHQ/docker-selenium). It is as easy as running this:

```shell
$ docker run -d -p 4444:4444 selenium/standalone-chrome:3.5.3-astatine
# OR
$ docker run -d -p 4444:4444 selenium/standalone-firefox:3.5.3-astatine
```
Done. I can't believe I didn't use this to start with. If your CI server has docker on it, I would recommend using these images. If it doesn't, then I would try to have it installed, or install it yourself, it's not that hard. Otherwise, you are in for a bumpy ride.

After writing front-end automation tests for about a month, I can honestly say that I did not hate it as much as I first thought I would and I probably won't snarl next time someone mentions Selenium. Hopefully the tests that I have been writing aren't too brittle, and are easy to understand for other developers and easy to fix when they do break.

